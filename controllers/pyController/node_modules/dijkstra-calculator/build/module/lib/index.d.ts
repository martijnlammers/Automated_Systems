/**
 * A unique identifier for the
 */
export declare type NodeId = string;
export interface Node {
    id: NodeId;
    priority: number;
}
export interface LinkedListItem {
    source: NodeId;
    target: NodeId;
}
export declare class DijkstraCalculator {
    adjacencyList: {
        [key: NodeId]: {
            id: NodeId;
            weight: number;
        }[];
    };
    constructor();
    addVertex(vertex: NodeId): void;
    addEdge(vertex1: NodeId, vertex2: NodeId, weight?: number): void;
    /**
     * Given the provided weights of each edge
     * @param start The starting {@link NodeId} to begin traversal
     * @param finish The ending {@link NodeId} to complete traversal
     * @returns an {@type Array<string>} showing how to traverse the nodes. If traversal is impossible then it will return an empty array
     */
    calculateShortestPath(start: NodeId, finish: NodeId): string[];
    /**
     * Creates a linked list of the result with each element with a source and target property
     * @param start The starting {@link NodeId} to begin traversal
     * @param finish The ending {@link NodeId} to complete traversal
     * @returns Returns an array where each element is a {@link LinkedListItem}
     */
    calculateShortestPathAsLinkedListResult(start: NodeId, finish: NodeId): LinkedListItem[];
}
